\subsubsection{PriorityQueue}

\constante{MAX}{256}

\begin{algorithme} 
\begin{enregistrement}{PriorityQueue}
    \champEnregistrement{elements}{\tableau{1..MAX}{de}{HuffmanTree}}
    \champEnregistrement{nbElements}{\naturelNonNul}
\end{enregistrement}
\end{algorithme}
\vspace*{0.5cm}

\begin{algorithme} 
    \fonction{PriorityQueueEmpty}{}{PriorityQueue}{} 
    {result : PriorityQueue}
        {\affecter{\champ{result}{nbElements}}{0}
            \retourner{result}}
\end{algorithme}
\vspace*{0.5cm}

\begin{algorithme}
    \procedure{addTree}{\paramEntreeSortie{queue: PriorityQueue} \paramEntree{tree: HuffmanTree}}{}
    {i : \naturelNonNul}
    {\affecter{i}{1}
    \affecter{\champ{queue}{nbElements}}{\champ{queue}{nbElements}+1}
    \tantque {\instruction{HuffmanTree.getOccurence(tree) < HuffmanTree.getOccurence(\champ{queue}{elements}[i])}}
    {\affecter{i}{i+1}}
    \instruction{decalerVersLaDroite(\champ{queue}{elements}, i, \champ{queue}{nbElements})}
    \affecter{\champ{queue}{elements}[i]}{tree}}
\end{algorithme}
\vspace*{0.5cm}

\begin{algorithme}
    \fonction{removeTree}{queue: PriorityQueue}{Tree}{sizeQueue(f) > 0}{}
    {\affecter{\champ{queue}{nbElements}}{\champ{queue}{nbElements}-1}
        \retourner{\champ{queue}{elements}[nbElements+1]}}
\end{algorithme}
\vspace*{0.5cm}

\begin{algorithme}
    \fonction{sizeQueue}{queue: PriorityQueue}{\naturel}{}{}
    {\retourner{\champ{queue}{nbElements}}}
\end{algorithme}
