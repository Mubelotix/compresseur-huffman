\subsubsection{PriorityQueue}

\constante{MAX}{256}

\begin{algorithme}
    \begin{enregistrement}{PriorityQueue}
        \champEnregistrement{elements}{\tableau{1..MAX}{de}{HuffmanTree}}
        \champEnregistrement{length}{\naturelNonNul}
    \end{enregistrement}
    \vspace*{0.5cm}

    \fonction{newPriorityQueue}{}{PriorityQueue}{}{result : PriorityQueue}{
        \affecter{\champ{result}{length}}{0}
        \retourner{result}
    }
    \vspace*{0.5cm}

    \fonction{getInsertionIndex}{queue: PriorityQueue, ht: HuffmanTree}{\naturel}{}{i : \naturelNonNul}{
        \affecter{i}{1}
        \tantque{getOccurrence(ht) > getOccurrence(\champ{queue}{elements}[i])}{
            \affecter{i}{i+1}
        }
        \retourner{i}
    }
    \vspace*{0.5cm}

    \procedure{shiftRight}{\paramEntreeSortie{queue: PriorityQueue}, \paramEntree{index: \naturel}}{index <= length(queue)}{i : \naturelNonNul}{
        \affecter{\champ{queue}{length}}{\champ{queue}{length}+1}
        \affecter{i}{\champ{queue}{length}}
        \tantque{i > index}{
            \affecter{\champ{queue}{elements}[i]}{\champ{queue}{elements}[i-1]}
            \affecter{i}{i-1}
        }
    }
    \vspace*{0.5cm}

    \procedure{insertTree}{\paramEntreeSortie{queue: PriorityQueue}, \paramEntree{ht: HuffmanTree}}{}{i : \naturelNonNul}{
        \affecter{i}{getInsertionIndex(queue, ht)}
        \instruction{shiftRight(queue, i)}
        \affecter{\champ{queue}{elements}[i]}{ht}
    }
    \vspace*{0.5cm}

    \fonction{popTree}{\paramEntreeSortie{queue: PriorityQueue}}{HuffmanTree}{not(isEmpty(queue))}{}{
        \affecter{\champ{queue}{length}}{\champ{queue}{length}-1}
        \retourner{\champ{queue}{elements}[\champ{queue}{length}+1]}
    }
\end{algorithme}
